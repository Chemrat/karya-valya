Message structure:
[header][body]

Header structure:
[body size][message type]
Body size and message type is 4 bytes variables (it means that the header size is 8 bytes).
Body size and message type are big endian

Body structure:
Json
(utf8)

Note:
Body should not be empty.
If there is not any data body should contains empty json object ("{}")

Examples:

System type:

[[0x00000031][0x00000001]]
[{"login" : "retard", "password" : "iamnotretard"}]

[[0x00000031][0x00000001]]
[{"url_to_upload_map" : "grief.ly/FFFFFFFFFFFFFFFF"}]

[[0x00000035][0x00000001]]
[{"url_to_download_map" : "grief.ly/FFFFFFFFFFFFFFFF"}]


Ordinary typa (aka keyboard type):
[[0x0000001C][0x00000002]]
[{"id" : 1, "key" : "KEY_UP"}]

[[0x00000020][0x00000002]]
[{"id" : 0, "key" : "CREATE_NEW"}]

Message type:
[[0x00000032][0x00000003]]
[{"id" : 1, "type" : "OOC", "text" : "Hello world"}]

LIST OF TYPES:

DEFINED TYPES:

MESSAGES TO SERVER FROM CLIENT:

1 - INITAL LOGIN MESSAGE
2 - EXIT_CLIENT

MESSAGES TO CLIENT FROM SERVER:

ERROR MESSAGES:
401 - WRONG GAME VERSION
402 - WRONG AUTHENTICATION
403 - UNDEFINED ERROR
404 - EXIT_SERVER

NON ERROR MESSAGES:
201 - SUCCESS CONNECTION
202 - MAP UPLOAD
203 - NEW TICK
204 - NEW CLIENT

GAME (BROADCASTED) TYPES:

They are used only in client (mostly)
1001 - oridnary/keyboard
{"key":"ENTER"}
1002 - message 
{"text":"some text"}

1003 - some complicated gui message
1004 - mouse click
{"obj":42}

1101 - hash message
{"hash":42,"tick":42}
1102 - ping message
{"ping_id":"42"}

PROTOCOL:

I. LOGIN STAGE

1. from CLIENT to SERVER:
protocol version, 4 bytes ("S132")

2. from CLIENT to SERVER
type: INITAL LOGIN MESSAGE
{"login" : "Someone", "password" : "12345", "game_version" : "v0.2.1"}

Note: if "login" == "Guest" then server should interpret this login as random not used login
 with empty ("") password, for example "Guest4242". Authentication will be always successful.

3.
(It is better to check game version first always)
b) WRONG GAME VERSION
 from SERVER to CLIENT
type: WRONG GAME VERSION
{"correct_game_version" : "v0.2.2"}
-> connection closed

a) WRONG LOGIN OR PASSWORD 
 from SERVER to CLIENT
type: WRONG AUTHENTICATION
(empty)
-> connection closed

c) MASTER CLIENT DOES NOT EXIST
 from SERVER to CLIENT
Server creates new client, gives number to him
type: SUCCESS CONNECTION
{"map" : "no_map", "your_id" : 42}
New client now master client

d) MASTER CLIENT EXISTS AND "login" DOES NOT HAVE ID
Server creates new client, gives number to him

 from SERVER to ALL CLIENTS (EXCEPT NEW CLIENT)
 type: NEW CLIENT
 "id" - new number for new client
{"id" : 42}

 from SERVER to MASTER CLIENT
 type: MAP UPLOAD
{"url_to_upload_map" : "grief.ly/blah"}

 from SERVER to CLIENT
type: SUCCESS CONNECTION
{"map" : "grief.ly/blah", "your_id" : 42}

c) MASTER CLIENT EXISTS AND "login" DOES HAVE ID
Server uses existing client info, takes number from that info

 from SERVER to MASTER CLIENT
 type: MAP UPLOAD
{"url_to_upload_map" : "grief.ly/blah"}

 from SERVER to CLIENT
type: SUCCESS CONNECTION
{"map" : "grief.ly/blah", "your_id" : 24}

d) UNDEFINED ERROR
For example, during the process master client disconnects, or something else

 from SERVER to CLIENT
 type UNDEFINED ERROR
(empty)

////////////////////////////////
END OF LOGIN STAGE

II. ACTIVE CONNECTION STAGE

No specific order

X - NOT DEFINED TYPE (X may be 1000, 2000 etc)
In other words, if other action is not defined for this type of the message then server should broadcast the message
message type >=1000

1. 

from CLIENT to SERVER
 type: X
{some json}

after that broadcast message

from SERVER to ALL CLIENTS (even inital client):
 type: X
{"id" : 42, some json}

"id" - number of initial client (message sender)

2.

Each T milliseconds (now T is 100, 10 messages per second)

from SERVER to CLIENT
 type: NEW_TICK
(empty)

///////////////
END OF ACTIVE CONNECTION STAGE

III. END CONNECTION STAGE

Client should send message on exit:
from CLIENT to SERVER
type EXIT_CLIENT
(empty)

Server if it closes connection (not WRONG GAME VERSION/etc cases) should send message on exit:
from SERVER to CLIENT
type EXIT_SERVER
(empty)

IF CLIENT CLOSES HIS CONNECTION:

a) It is a regular client

Server should remove this client from the client list.
Note that when any new client will be created server should not reuse numbers for clients.
So we dont send to this client messages anymore, but we still keep information about it (login + number, maybe something
else later (ip?)).

b) It is master client, and there is at least one other client.

Make a) with master client, but make some client (in future here will be some heuristic probably) master client.
If master client happens during a new client connection - we do not care.
The master client disconnection should be really rare case

c) It is master client, and there is no any other clients.

Forget everything. Basically, restart server (well, at least do not keep information about logins + ids)

//////////
END OF END CONNECTION STAGE

HOW CLIENT UPLOADS MAP TO SERVER:
POST request to some url ("grief.ly/blah")
Content-Length as header
Binary map in the body of the POST request.
Response 200 OK
Other responses - error.

HOW CLIENT DOWNLOADS MAP FROM SERVER
GET request to some url ("grief.ly/blah")
Response 200 OK
Content-Length in the response
Content-Type: application/octet-stream in the response
Body is the binary map
Response 200 OK
Other responses - error.
































